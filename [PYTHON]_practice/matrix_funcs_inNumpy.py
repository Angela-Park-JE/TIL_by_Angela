### linespace
# 첫 번째 값부터 두 번째 값을 세 번쨰 값 개수로 나누겠다는 넘파이 함수이다.
# np.linespace

>>> np.linespace(1,3,3)

array([1., 2., 3.])

>>> np.linspace(4,6,3)

array([4., 5., 6.])



### meshgrid
# 격자를 만드는 것. x축과 y축의 격자를 만드는 함수라고 생각 하면 된다.
# np.meshgrid

>>> a = np.meshgrid([1,2,3] ,[4,5,6])
>>> a

[array([[1, 2, 3],
        [1, 2, 3],
        [1, 2, 3]]), array([[4, 4, 4],
        [5, 5, 5],
        [6, 6, 6]])]

>>> a[0]

array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]])



### 두 함수를 사용하여 행렬을 만든다면

>>> np.meshgrid(np.linspace(1,3,3), np.linspace(4,6,3))

[array([[1., 2., 3.],
        [1., 2., 3.],
        [1., 2., 3.]]), array([[4., 4., 4.],
        [5., 5., 5.],
        [6., 6., 6.]])]



### ravel, reshape, flatten과 복사의 차원
# 행렬을 펼쳐주는 함수들이다. 그러나 이 세 가지는 각각 다르게 쓰인다.
# 가장 큰 차이점으로 나눈다면, 원본 동기화된 상태로 가져오는 것과 유지하지 않고 복사해오는 것으로 나뉜다.
# ravel, reshape 는 종속되고, 
# flatten은 독립되어 완전한 복사가 이루어지는 함수이다.

# 실험하기 : b를 0,1 2,3 으로 이루어진 행렬로 정해준다.
>>> b = b.array([[0,1],
               [2,3]])

# ravel()
>>> b1 = b.ravel()
>>> b1

array([0, 1, 2, 3])

# reshape()
>>> b2 = b.reshape(-1)
>>> b2

array([0, 1, 2, 3])

# flatten()
>>> b3 = b.flatten()
>>> b3

array([0, 1, 2, 3])

# 세 함수를 각기 다른 변수에 담았고, 모두 같은 결과를 내보냈다. 
# 그러나 원본 array을 수정했을 때는 다르다.

# 원본 수정 및 출력
>>> b[0][0] = -1
>>> print(b)
    print(b1) 
    print(b2) 
    print(b3) 

[[-1  1]
 [ 2  3]] 
[-1  1  2  3] # ravel: 원본과 영향 O, 완전 복사 X
[-1  1  2  3] # reshape: 원본과 영향 O 
[0 1 2 3]     # flatten: 원본과 영향 X



### copy
# 완전한 복사를 하기 위해서는 copy()를 쓰면 된다.

>>> c = b.copy()
>>> c

array([[0, 1],
       [2, 3]])
